---
layout: post
category : C
tagline: "basic of C"
tags : [C]
title : 具有代码块作用域的静态变量
articleType : blog
---

> 有关输入、输出以及缓冲和非缓冲输入之间的区别的更多内容
> 从键盘模拟文件结尾条件的方法
> 如何重定向将你的程序与文件相连接
> 使用户界面更加友好

在计算机世界中，我们在很多场合下都使用词语输入（input）和输出（output），例如，在讲输入和输出设备（如键盘、磁盘驱动器和激光打印机等）时，在指用于输入和输出的数据时，以及在指执行输入和输出任务的函数时。
I/O函数将信息传输至你的程序并从你的程序中传出信息；printf()、scanf()、getchar()和put char()就是这样的例子。
最初，输入／输出函数并不是C定义的一部分。输入输出的开发是留给C来实现完成的。在实践中，C的Unix实现已经作为这些函数的一个模型。认可过去惯例的ANSI C库中包含大量这些Unix的I/O函数。
许多程序面临的一个重要任务是确认输入；也就是说，确定用户的输入是否与程序所希望的输入相匹配。 

###单字符I/O：getchar()和putchar()

getchar()和putchar()每次输入和输出一个字符。你可能觉得这种方法是一种很笨的处理问题的方法。当然了，你可以很容易地读取多于单个字符的一组数据，但是该方法确实适合计算机的能力。而且，此方法是大多数处理文本（即普通单词）的程序的核心。要会想起这些函数的工作方式，就看下面这个例子：

    /* echo.c */
    #include <stdio.h>
    int main(void) {
      char ch;
      while((ch=getchar()) != '#')
        putchar(ch);
      return 0;
    }
    
ANSI C将stdio.h头文件与使用getchar()和putchar()相关联，这就是我们在程序中将该文件包含在内的原因。程序运行的结果如下：

    Hello,there.I would[enter]
    hello,there.I would
    like a #3 bag of potatoes.[enter]
    like a 
    
###缓冲区

当你在一些系统上运行前面的程序时，你所输入的文本立即回显。也就是说，一个可能的运行示例如下所示：
hheelllloo,,tthheerree..II wwoouulldd[enter]lliikkee  aa  #
前面所描述的行为是例外的情况。在大多数系统上，在你按下回车键之前什么都不会发生，正如在第一个例子中所示。输入字符的立即回显是非缓冲(unbuffered)或直接(direct)输入的一个实例。它表示你所键入的字符对正在等待的程序立即变为可用。相反，延迟回显是缓冲(buffered)输入的实例，这种情况下你所键入的字符被收集并存储在一个被称为缓冲区(buffer)的临时存储区域中。按下回车键可使你所键入字符块队程序变为可用。如图所示：

![缓冲区](img/1.png)

###为何需要缓冲区？

1、将若干个字符作为一个块传输比逐个发送这些字符耗费的时间少
2、如果你输入有误，就可以使用你的键盘更正功能来修复错误，当最终按下回车键的时候，你就可以发送正确的输入。
3、另一方面，有些交互性的程序需要非缓冲输入，比如，游戏中你希望一按下键就执行某个命令。

因此，缓冲区和非缓冲区具备各自的用途。
缓冲分为两种：
>完全缓冲(fully buffered) I/O
>行缓冲(line-buffered) I/O
对于完全缓冲来说，缓冲区满时被清空（内容被发送至其目的地）。这种类型的缓冲通常出现在文件输入中。缓冲区的大小取决于系统，但512字节和4096字节是常见的值。
对于行缓冲I/O来说，遇到一个换行字符时将被清空缓冲区，键盘输入是标准的行缓冲，因此按下回车键将清空缓冲区。